import { CodeBlock } from '../CodeBlock.tsx';
export const script = `import Enmap from 'enmap';
import { Josh } from '@joshdb/core';
import { Provider } from 'provider';

// Initialize your Enmap instance.
// Make sure all options coordinate with your options in the rest of your project.
// However, we must make sure to use the "fetchAll" option here.
const source = new Enmap({
  name: 'source',
  fetchAll: true
});

// Initialize you Josh instance.
// Remember to add any options to your provider if needed.
const target = new Josh({
  name: 'target',
  provider: new Provider()
});

// Create a migration function.
async function migrate() {

  // Ensure sure the "source" is ready.
  await source.defer;

  // Let's log how many keys we have in the source database.
  console.log(\`Source database has \${source.count} rows.\`);

  // Let's log how many keys we have in the target database.
  console.log(\`Target database has \${await target.size()} rows.\`);

  // Get the exported json data from Enmap.
  const data = source.export();

  // Import the data into Josh.
  await target.import(data);
  console.log(\`Migration complete! Target database now has \${await target.size()} keys.\`);
}

// Run the migration.
migrate();`;
export const methodDiff = `- enmap.autonum;
+ await josh.autoKey();

- enmap.size;
- enmap.count;
+ await josh.size();

- enmap.array();
- enmap.values();
+ await josh.values();

- enmap.findAll();
+ await josh.filter();

- enmap.exists();
+ await josh.has();
`

# Migrating from Enmap

While Josh and Enmap are based on the same basic concepts and ideas.
This being said, there are still many changes that will need to be done in your code if you want to migrate from Enmap to Josh.

## Why should I migrate?

You should not migrate to Josh, "because it's newer".
Josh is not an upgrade to Enmap, it's an entirely different package altogether.

Anyways, here are a few reason you _should_ migrate:

- It can be used across multiple processes.
  This is useful for projects such as a Discord bot which may need sharding or access to a database in an API backend _and_ frontend.
- It has provider support, so it not only supports SQLite, but also Mongo, JSON, PostgreSQL, plus many more.
- It has bundles in ESM and CommonJS.
  This makes it possible for you to use Josh in many different project environments.

## Prerequisites

- Josh utilizes promises _everywhere_, so you need to be familiar with them.
  If you don't know how to use promises, you can learn them [here](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise).
- Make a backup of your project's database files before you migrate.

## Migrating

To start out we can create a new file called `migrations.js` in the same place you main entry point is in your project. Generally this would be a `index.js` or `main.js`.
Remember, anywhere we use the `provider` keyword, you should reference the provider you are using in your project.

<CodeBlock lang='ts' code={script} />

### Changing your Code

Here is the more difficult part of the migration. You'll need to change your entire codebase for Josh.
As long as you follow these differences carefully you will be running your project using Josh in no time!

#### Methods

Below is a list of all methods and properties that have changes in their name, usage, and/or signatures.

<CodeBlock lang='diff' code={methodDiff} />

Methods that will not be implemented:

- `fetch()` and `fetchEverything()`. This is no longer required and is not relevant.
- `evict()`. This is no longer required and is not relevant.
- `changed()`. Cannot be implemented.
- `sweep()`, `clone()`, and `equals()`. This no longer required and is not relevant.
- `setProp()`, `pushIn()`, `getProp()`, `deleteProp()`, `removeFrom()`, and `hasProp()`. They're deprecated and can all be done with the simple key/path system.
- `filterArray()`. Unnecessary method.

## Conclusion

Alright, this is quite a hefty page, with a lot of information.
Thank you for using Josh and I hope you found this migration guide very informative!
